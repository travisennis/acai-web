Hono Best Practices:

Use Hono's built-in middleware for common tasks like CORS and compression
Implement proper error handling using Hono's error handling mechanisms
Utilize Hono's routing system for clean and maintainable route definitions
Leverage Hono's context object for efficient data passing between middleware
Implement proper security measures like input validation and rate limiting

Socket.io Best Practices:

Use Socket.io's built-in authentication mechanisms for secure connections
Implement proper error handling and disconnection logic
Utilize Socket.io's rooms feature for efficient broadcasting to specific groups
Leverage Socket.io's compression for improved performance on large payloads
Implement proper rate limiting to prevent abuse and ensure fair usage

Redis Best Practices:

Use Redis connection pooling for improved performance and resource management
Implement proper error handling and reconnection logic
Utilize Redis transactions for atomic operations
Leverage Redis pub/sub for real-time communication between different parts of your application
Implement proper data expiration policies to manage memory usage

Mongoose Best Practices:

Use Mongoose schemas with proper validation for data integrity
Implement proper error handling and connection management
Utilize Mongoose middleware for common operations like logging and data transformation
Leverage Mongoose's population feature for efficient data retrieval
Implement proper indexing for improved query performance

Zod Best Practices:

Use Zod for runtime type checking and data validation
Implement proper error handling and custom error messages
Utilize Zod's built-in parsing and transformation capabilities
Leverage Zod's integration with other libraries like Hono for seamless validation
Implement proper schema reuse and composition for maintainable validation logic

AI SDK Best Practices:

Use the appropriate AI SDK for your chosen AI provider
Implement proper error handling and rate limiting
Utilize the SDK's streaming capabilities for improved performance on large responses
Leverage the SDK's built-in features like function calling and tool usage
Implement proper security measures like API key management and request validation

General Standards:

Implement comprehensive logging and monitoring for better observability
Follow proper code organization and modularization for maintainability
Implement proper testing practices including unit tests and integration tests
Utilize environment variables for configuration and sensitive data management
Implement proper security measures like input validation and authentication across all layers of your application
